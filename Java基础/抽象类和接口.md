# 抽象类和接口

**要点：**父类中定义了相关子类中的共同行为。接口可以用于定义类的共同行为（包括非相关的类）。



## 1.抽象类（abstract class）：

**要点：**抽象类不可以用于创建对象。抽象类可以包含抽象方法，这些方法将在具体的子类中实现。一个父类设计得非常抽象，以至于他都没有任何具体的实例。这样的类称为**抽象类**。通过**extends**继承。



**注意：**

- 不能使用new操作符创建抽象类的实例。但是抽象类可以做一种数据类型。例如创建一个元素是抽象类型的数组：AbstractDemo[] object = new AbstractDemo[10];      然后创建一个AbstractDemo的实例ExtendsDemo，并将它的引用赋值给数组：object[0] = new ExtendsDemo();

- 抽象类的构造方法定义为protected，因为它只被子类调用。创建一个具体子类的实例时，它的父类的构造方法在子类的构造方法中被调用，以初始化父类中定义的数据域。

- 一个包含抽象方法的类必须声明为抽象类。如果抽象父类的子类不能实现所有的抽象方法，那么子类也必须定义为抽象的。可以定义一个不包含抽象方法的抽象类，这种类是用来定义新子类的基类的。

- 抽象方法只有定义没有实现，它的实现由子类提供。

- 子类可以覆盖父类的方法并将它定义为abstract。当父类的方法是现在子类中变得无效时子类必须定义为abstract。

- 即使父类是具体的，子类也可以是抽象的。例如Object类是具体的。

  



## 2.接口（interface）：

**要点：**接口是一种与类相似的结构，只包含**常量**和**公共抽象方法**。接口的目的是指明相关或者不相关类的多个对象的共同行为。通过**implements**实现接口继承。



**注意：**

- 与抽象类相似，不能使用new创建接口的实例。
- 接口中所有的数据域都是public static final，而且所有的方法都是public abstract，所以接口中可以忽略这些修饰符。
- 一个带空体的接口称为*标记接口*，标记接口既不包括常量也不包括方法，它用来表示一个类拥有某些特定的属性。例如Cloneable接口。





## 3.接口与抽象类：

**要点：**一个类可以实现多个接口，但是只能继承一个父类。



|        |                变量                 |                      方法                       |                           构造方法                           |
| :----: | :---------------------------------: | :---------------------------------------------: | :----------------------------------------------------------: |
| 抽象类 |               无要求                |                     无要求                      | 子类通过构造方法链调用构造方法。抽象类不能用new操作符实例化。 |
|  接口  | 所有的变量必须是public static final | 所有方法必须是公共的抽象实例方法public abstract |          没有构造方法。接口不能用new操作符实例化。           |



利用关键字extends，接口可以继承其他接口，这样的接口称为子接口。一个实现子接口的类必须实现其他父接口中定义的抽象方法。

推荐使用接口而非抽象类 ，因为接口可以定义非相关类共有的父类型。然而，接口不能有具体的方法，可以结合接口和抽象类的优点，创建一个接口，使用一个抽象类来实现它。